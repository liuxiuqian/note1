

# 面试题

## 一、vue2.0部分



### 1、v-show和v-if的区别

- v-show 通过 css display 控制显示和隐藏的
- v-if 是组件真正的渲染和销毁，不是显示和隐藏
- 频换切换的时候使用 v-show , 否则使用 v-if 

### 2、v-for中key的作用

diff 算法中通过 tag 和 key 来判断是否是 sameNode ，减少渲染次数，提升渲染性能。key 必须使用的 不能是 index 和 random 。

### 3、v-for 和 v-if不能同时使用

v-for 比v-if计算优先级高 而且如果每一次都需要遍历整个数组，将会影响速度，
解决方案 使用计算属性 computed 或者在父级标签判断

### 4、vue的生命周期（有父子组件的情况）
主要有三个阶段：

1. 创建阶段（注册实例与挂载）： beforeCreate、created、beforeMount、mounted
2. 更新阶段：beforeUpdate、updated
3. 注销阶段：beforeDestroy、destroyed

单个组件的生命按正常的顺序执行。这里主要说一下父子组件的情况

1. 创建阶段： 父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted
2. 子组件更新过程： 父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
3. 父组件更新过程：父 beforeUpdate -> 父 updated
4. 销毁过程： 父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

### 5、vue组件如何通讯


- 父子组件：父子沟通用的是props，子父沟通用的是 this.$emit
- 自定义事件： event.$no event.$off event.$emit
- vuex

### 6、对 mvvm 的理解

view -> viewModel -> model
view <- viewModel <- model

view: DOM
model: javascript Objects
viewModel: vue (DOM listeners 和 directives )

### 7、双向数据绑定v-model 的实现原理

v-model 是一个语法糖真正实现是靠 v-bind绑定响应式数据和触发oninput 事件并传递数据实现，

- input 元素的 value = this.name
- 绑定 input 事件 this.name = $event.target.value
- data 更新出发 re-render

自定义 v-model 
- 定一个 props ,在 model 中 关联 prop:"自己定义的属性默认为 value ", enent:"事件名称默认为 input "


### 8、$nextTick

异步渲染，将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。

### 9、slot

#### 1）、什么是插槽？

- 插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。
- 插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制

#### 2）、默认插槽

父组件

    <template>
	  <div>
	    我是父组件
	    <slotOne1>
	      <p style="color:red">我是父组件插槽内容</p>
	    </slotOne1>
	  </div>
	</template>

在父组件引用的子组件中写入想要显示的内容（可以使用标签，也可以不用）

子组件(slotOne1)

    <template>
	  <div class="slotOne1">
	    <div>我是slotOne1组件</div>
	    <slot></slot>
	  </div>
	</template>

在子组件中写入slot，slot所在的位置就是父组件要显示的内容

#### 3）、具名插槽

子组件

	<template>
	  <div class="slottwo">
	    <div>slottwo</div>
	    <slot name="header"></slot>
	    <slot></slot>
	    <slot name="footer"></slot>
	  </div>
	</template>
在子组件中定义了三个slot标签，其中有两个分别添加了name属性header和footer

父组件

	<template>
	  <div>
	    我是父组件
	    <slot-two>
	      <p>啦啦啦，啦啦啦，我是卖报的小行家</p>
	      <template slot="header">
	          <p>我是name为header的slot</p>
	      </template>
	      <p slot="footer">我是name为footer的slot</p>
	    </slot-two>
	  </div>
	</template>

在父组件中使用template并写入对应的slot值来指定该内容在子组件中现实的位置（当然也不用必须写到template），没有对应值的其他内容会被放到子组件中没有添加name属性的slot中

#### 4）、作用域插槽

子组件

    <template>
	  <div>
	    我是作用域插槽的子组件
	    <slot :data="user"></slot>
	  </div>
	</template>
	
	<script>
	export default {
	  name: 'slotthree',
	  data () {
	    return {
	      user: [
	        {name: 'Jack', sex: 'boy'},
	        {name: 'Jone', sex: 'girl'},
	        {name: 'Tom', sex: 'boy'}
	      ]
	    }
	  }
	}
	</script>

在子组件的slot标签上绑定需要的值

父组件

	<template>
	  <div>
	    我是作用域插槽
	    <slot-three>
	      <template slot-scope="user">
	        <div v-for="(item, index) in user.data" :key="index">
	        {{item}}
	        </div>
	      </template>
	    </slot-three>
	  </div>
	</template>
在父组件上使用slot-scope属性，user.data就是子组件传过来的值



### 10、keep-alive 

- 缓存组件
- 频繁切换，不需要重新渲染
- Vue的性能优化

Props：

- include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
- exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
- max - 数字。最多可以缓存多少组件实例。

使用：

    <!-- 基本 -->
	<keep-alive>
	  <component :is="view"></component>
	</keep-alive>
	
	<!-- 多个条件判断的子组件 -->
	<keep-alive>
	  <comp-a v-if="a > 1"></comp-a>
	  <comp-b v-else></comp-b>
	</keep-alive>
	
	<!-- 和 `<transition>` 一起使用 -->
	<transition>
	  <keep-alive>
	    <component :is="view"></component>
	  </keep-alive>
	</transition>

include 和 exclude prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：

	<!-- 逗号分隔字符串 -->
	<keep-alive include="a,b">
	  <component :is="view"></component>
	</keep-alive>
	
	<!-- 正则表达式 (使用 `v-bind`) -->
	<keep-alive :include="/a|b/">
	  <component :is="view"></component>
	</keep-alive>
	
	<!-- 数组 (使用 `v-bind`) -->
	<keep-alive :include="['a', 'b']">
	  <component :is="view"></component>
	</keep-alive>

max：最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。

	<keep-alive :max="10">
	  <component :is="view"></component>
	</keep-alive>

### 11、vuex 

- state：  数据仓库，唯一数据源
- getters：  store 的计算属性。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
- action： Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。
- mutation： 更改 Vuex 的 store 中的状态的唯一方法

用于组件中的

- dispatch：
- commit：
- mapState：
- mapGetters：
- mapActions：
- mapMutations：


### 12、vue 响应式原理

核心API: Object.defineProperty 

Object.defineProperty 的简单使用：

    Object.defineProperty(obj, prop, desc)

1. obj 需要定义属性的当前对象
2. prop 当前需要定义的属性名
3. desc 属性描述符（）


     	let Person = {}
		let temp = null
		Object.defineProperty(Person, 'name', {
			get: function () {
				console.log("get");
				return temp
			},
			set: function (val) {
				console.log("set",val);
				temp = val
			}
		})
	
		Person.name = "风信子"
		console.log(Person.name)

Object.defineProperty如何监听数组和对象

    // 触发更新视图
	function updateView() {
	    console.log('视图更新')
	}
	
	// 重新定义数组原型
	const oldArrayProperty = Array.prototype
	// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型
	const arrProto = Object.create(oldArrayProperty);
	['push', 'pop', 'shift', 'unshift', 'splice'].forEach(methodName => {
	    arrProto[methodName] = function () {
	        updateView() // 触发视图更新
	        oldArrayProperty[methodName].call(this, ...arguments)
	        // Array.prototype.push.call(this, ...arguments)
	    }
	})
	
	// 重新定义属性，监听起来
	function defineReactive(target, key, value) {
	    // 深度监听
	    observer(value)
	
	    // 核心 API
	    Object.defineProperty(target, key, {
	        get() {
	            return value
	        },
	        set(newValue) {
	            if (newValue !== value) {
	                // 深度监听 (设置新值的时候)
	                observer(newValue)
	
	                // 设置新值
	                // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值
	                value = newValue
	
	                // 触发更新视图
	                updateView()
	            }
	        }
	    })
	}
	
	// 监听对象属性
	function observer(target) {
	    if (typeof target !== 'object' || target === null) {
	        // 不是对象或数组
	        return target
	    }
	
	    // 污染全局的 Array 原型
	    // Array.prototype.push = function () {
	    //     updateView()
	    //     ...
	    // }
	
	    if (Array.isArray(target)) {
	        target.__proto__ = arrProto
	    }
	
	    // 重新定义各个属性（for in 也可以遍历数组）
	    for (let key in target) {
	        defineReactive(target, key, target[key])
	    }
	}
	
	// 准备数据
	const data = {
	    name: 'zhangsan',
	    age: 20,
	    info: {
	        address: '北京' // 需要深度监听
	    },
	    nums: [10, 20, 30]
	}
	
	// 监听数据
	observer(data)
	
	// 测试
	// data.name = 'lisi'
	// data.age = 21
	// // console.log('age', data.age)
	// data.x = '100' // 新增属性，监听不到 —— 所以有 Vue.set
	// delete data.name // 删除属性，监听不到 —— 所有已 Vue.delete
	// data.info.address = '上海' // 深度监听
	data.nums.push(4) // 监听数组


Object.defineProperty 的缺点（Vue3.0启用Proxy）

- 深度监听，需要递归到底，一次性计算量大
- 无法监听新增属性/删除属性 （没有在data中初始化的属性，需要vue.set(),vue.delete()）
- 无法原生监听数组，需要特殊处理

Proxy 有兼容性问题 无法兼容polyfill


### 13、虚拟DOM (virtual DOM)

DOM 操作非常耗费性能，之前需手动操作DOM。Vue和React是数据驱动视图，如何操作DOM.

解决方案-VDOM：
项目有了一定复杂度，想减少计算次数比较难。能不能把计算，更多的转移为js计算，因为js执行速度相对很快的。

vdom: 用js模拟DOM结构，计算出最小的变更，操作DOM



#### 1）用js模拟DOM结构原理

	// 原html结构
    	<div class="content">
				<ul style="font-size:20px;" >
					<li>a</li>
				</ul>
			</div>
	//js模拟DOM结构
	{
		tag:"div",
		props:{
			className:"content",
			id:"div1"
		},
		childrent:{
			tag:"ul",
			props:{
				style:"font-size:20px;",
			},
			childrent:{
				tag:"li",
				childrent:"a"
			}
		}
	}

#### 2）通过 snabbdom 学习 vdom

##### （1） diff算法概述

- diff即对比，是一个广泛的概念，如linux diff命令、git diff等
- 两个js 也可以 diff 对比。如：[https://github.com/cujojs/jiff](https://github.com/cujojs/jiff "https://github.com/cujojs/jiff")
- 两棵树做 diff , 如 vdom diff。
 
diff算法时间复杂度O(n) o(n): 1千个节点 时间复杂度就是1千。

时间复杂度如何优化到O(n)

1. 只比较同级，不跨级比较，减少算法复杂度。
2. tag 不相同，则直接删除重建，不在深度比较。
3. tag 和 key ，两个相同，则认为是相同节点，不在深度比较。

##### （2） diff算法总结

钩子方法 ：

	// 钩子
	export interface Hooks {
	    // 在 `patch` 开始执行的时候调用
	    pre?: PreHook;
	
	    // 在 `createElm`，进入的时候调用init
	    // vnode转换为真实DOM节点时触发
	    init?: InitHook;
	
	    // 创建真实DOM的时候，调用 create
	    create?: CreateHook;
	
	    // 在`patch`方法接近完成的时候，才收集所有的插入节点，遍历调用响应的钩子
	    // 可以认为插入到DOM树时触发
	    insert?: InsertHook;
	
	    // 在两个节点开始对比前调用
	    prepatch?: PrePatchHook;
	
	    // 更新过程中，调用update
	    update?: UpdateHook;
	
	    // 两个节点对比完成时候调用
	    postpatch?: PostPatchHook;
	
	    // 删除节点的时候调用，包括子节点的destroy也会被触发
	    destroy?: DestroyHook;
	
	    // 删除当前节点的时候调用。元素从父节点删除时触发，和destory略有不同，remove只影响到被移除节点中最顶层的节点
	    remove?: RemoveHook;
	
	    // 在`patch`方法的最后调用，也就是patch完成后触发
	    post?: PostHook;
	}

每个 modules 下的 hook 方法提取出来存到 cbs 里面

sameVnode：判断是否是相同的虚拟节点


patch：init 方法最后返回一个 patch 方法 。

patch 方法主要的逻辑如下 ：

- 触发 pre 钩子
- 如果老节点非 vnode， 则新创建空的 vnode
- 新旧节点为 sameVnode 的话，则调用 patchVnode 更新 vnode , 否则创建新节点
- 触发收集到的新元素 insert 钩子
- 触发 post 钩子

patchVnode 函数：比较两个vnode节点是否相似 相似patch 不同直接进行移除和添加

patchVnode 方法主要的逻辑如下 ：

- 触发 prepatch 钩子
- 触发 update 钩子， 这里主要为了更新对应的 module 内容
- 非文本节点的情况 , 调用 updateChildren 更新所有子节点
- 文本节点的情况 ， 直接 api.setTextContent(elm, vnode.text as string);


updateChildren 方法：patchVnode 里面最重要的方法，也是整个 diff 里面的最核心方法

updateChildren 主要的逻辑如下：

 
1. 优先处理特殊场景，先对比两端。也就是

	- 旧 vnode 头 vs 新 vnode 头
	- 旧 vnode 尾 vs 新 vnode 尾
	- 旧 vnode 头 vs 新 vnode 尾
	- 旧 vnode 尾 vs 新 vnode 头

2. 拿新节点的key，能否对应上 oldCh 中的某个节点的key。 找不到则新建元素
3. 如果找到 key，但是，元素选择器变化了，也新建元素
4. 如果找到 key，并且元素选择没变， 则移动元素
5. 两个列表对比完之后，清理多余的元素，新增添加的元素

addVnodes 方法： 

addVnodes 就比较简单了，主要功能就是添加 Vnodes 到 真实 DOM 中

removeVnodes 方法：

删除 VNodes 的主要逻辑如下：

- 循环触发 destroy 钩子，递归触发子节点的钩子
- 触发 remove 钩子,利用 createRmCb , 在所有监听器执行后，才调用 api.removeChild,删除真正的 DOM 节点


createElm 方法：

主要逻辑如下：

- 触发 init 钩子
- 处理注释节点
- 创建元素并设置 id , class
- 触发模块 create 钩子 。
- 处理子节点
- 处理文本节点
- 触发 vnodeData 的 create 钩子

详细请看系列文章结束：[https://segmentfault.com/a/1190000017519084](https://segmentfault.com/a/1190000017519084 "https://segmentfault.com/a/1190000017519084")

### 14、模板编译


- 模板不是html,有指令、插值、js表达式、能实现判断、循环
- HTML是标签，只有js才能实现判断、循环（图灵完备语言）
- 模板一定转换为某种js代码，即编译模板


#### 1）、 js 的 with 语法

    // 使用 with 能够改变 {} 内自由变量的查找方式
	// 将 {} 内自由变量当做 obj 的属性来查找,如果找不到会报错，
	// 不建议使用，打破了作用域规则，
	  const obj = {
	    a: 1000,
	    b: 1000
	  }
	
	  with(obj){
	    console.log(a);
	    console.log(b);
	    console.log(c); // 报错 c is not defined
	  }
  

#### 2）、vue template complier 将模板编译成 render 函数

	const compiler = require('vue-template-compiler')

	// 插值
	// const template = `<p>{{message}}</p>`
	// with(this){return createElement('p',[createTextVNode(toString(message))])}
	// h -> vnode
	// createElement -> vnode
	
	// // 表达式
	// const template = `<p>{{flag ? message : 'no message found'}}</p>`
	// // with(this){return _c('p',[_v(_s(flag ? message : 'no message found'))])}
	
	// // 属性和动态属性
	// const template = `
	//     <div id="div1" class="container">
	//         <img :src="imgUrl"/>
	//     </div>
	// `
	// with(this){return _c('div',
	//      {staticClass:"container",attrs:{"id":"div1"}},
	//      [
	//          _c('img',{attrs:{"src":imgUrl}})])}
	
	// // 条件
	// const template = `
	//     <div>
	//         <p v-if="flag === 'a'">A</p>
	//         <p v-else>B</p>
	//     </div>
	// `
	// with(this){return _c('div',[(flag === 'a')?_c('p',[_v("A")]):_c('p',[_v("B")])])}
	
	// 循环
	// const template = `
	//     <ul>
	//         <li v-for="item in list" :key="item.id">{{item.title}}</li>
	//     </ul>
	// `
	// with(this){return _c('ul',_l((list),function(item){return _c('li',{key:item.id},[_v(_s(item.title))])}),0)}
	
	// 事件
	// const template = `
	//     <button @click="clickHandler">submit</button>
	// `
	// with(this){return _c('button',{on:{"click":clickHandler}},[_v("submit")])}
	
	// v-model
	const template = `<input type="text" v-model="name">`
	// 主要看 input 事件
	// with(this){return _c('input',{directives:[{name:"model",rawName:"v-model",value:(name),expression:"name"}],attrs:{"type":"text"},domProps:{"value":(name)},on:{"input":function($event){if($event.target.composing)return;name=$event.target.value}}})}
	
	// render 函数
	// 返回 vnode
	// patch
	
	// 编译
	const res = compiler.compile(template)
	console.log(res.render)
	
	// ---------------分割线--------------
	
	// // 从 vue 源码中找到缩写函数的含义
	// function installRenderHelpers (target) {
	//     target._o = markOnce;
	//     target._n = toNumber;
	//     target._s = toString;
	//     target._l = renderList;
	//     target._t = renderSlot;
	//     target._q = looseEqual;
	//     target._i = looseIndexOf;
	//     target._m = renderStatic;
	//     target._f = resolveFilter;
	//     target._k = checkKeyCodes;
	//     target._b = bindObjectProps;
	//     target._v = createTextVNode;
	//     target._e = createEmptyVNode;
	//     target._u = resolveScopedSlots;
	//     target._g = bindObjectListeners;
	//     target._d = bindDynamicKeys;
	//     target._p = prependModifier;
	// }



#### 3）、执行 render 函数生成 vnode

VNode表示Virtual DOM，用JavaScript对象来描述真实的DOM把DOM标签，属性，内容都变成对象的属性。

详见上边 js 模拟 Dom  元素

### 15、渲染和更新过程

回顾知识：vue的三大核心

1. 响应式：监听 data 属性 getter setter (包括数组)。Object.defineProperty
2. 模板编译：模板到 render 函数 再到 vnode
3. vdom: patch(elem,vnode)vnode渲染的新的elem 和 patch(vnode,newVnode) 新的vode更新到旧的vnode。

#### 1）、初次渲染过程

- 解析模板为 render 函数 （或者在开发环境已完成，vue-loader）
- 触发响应式，监听 data 属性 getter setter （会触发和模板（视图）有关的变量）
- 执行 render 函数，生成 vnode， patch(elem,vnode)

#### 2）、更新过程

- 修改data，触发 setter （此前在 getter 中已被监听）
- 重新执行 render 函数，生成 newVnode
- patch(vnode,newVnode)


#### 3）、异步渲染

- $nextTick 函数
- 汇总 data 的修改，一次性更新视图
- 减少 DOM 操作次数，提高性能

### 16、前端路由原理

#### 1）、hash模式

- hash 变化会触发网页跳转，即浏览器的前进、后退
- hash 变化不会刷新页面，spa必须的特点
- hsah 永远不会提交到 server 端
- window.onhashchange 监听

#### 2）、 H5 history模式

- 用url规范的路由，但跳转时不刷新页面(只是刷新刚进来的页面)
- history.pushState （此方式，跳转浏览器不会刷新页面）
- window.onpopstate (监听浏览器前进和后退，由history.pushState()或者history.replaceState()形成的历史节点中前进后退)

to B 的系统推荐使用 hash,简单易用，对 url 规范不敏感。

to C 的系统，可以选着 H5 history，对于 seo 优化的使用 H5 history

### 17、computed 的特点

- 缓存，data 不变不会重新计算。
- 提高性能

### 18、为何组件 data 必须是个函数

data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象,通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。

### 19、数据请求应该刚在那个生命周期

- mounted
- js 是单线程的，数据请求异步获取数据
- 放在 mounted 之前是没有用的，只会让逻辑更加混乱，在 js 没有渲染完 异步数据也是在查询中不会提前加载。

### 20、如何将组建所有 props 传递给子组件

- $props (v-bind="$props")

### 21、多个组件有相同的逻辑，如何抽离

使用 mixin 

多个组件可以共享数据和方法，在使用mixin的组件中引入后，mixin中的方法和属性也就并入到该组件中，可以直接使用。数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。钩子函数会两个都被调用，mixin中的钩子首先执行。

存在问题：

变量来源不明确，多 mixin 可能造成命名冲突。 mixin 和组件可能存在多对多的关系，业务逻辑复杂。 

### 22、何时使用异步组件

- 加载大组件
- 路由异步加载

### 23、何时使用 keep-alive

- 缓存组件，不需要重复渲染
- 多个静态的 tab 页

### 24、何时使用 beforeDestory

- 解除自定义事件 event.$off
- 清除定时器
- 解除自定义 DOM 事件，如 window scroll 等。

### 25、请用 vnode 描述一个 DOM 结构

详见 用js模拟DOM结构原理

### 26、监听data 变化的核心 API 是什么

详见  vue 响应式原理 Object.defineProperty

### 27、vue 常见性能优化

- 合理使用 v-show 和 v-if
- 合理使用computed
- v-for 时加 key , 避免和 v-if 同时使用
- 自定义事件个dom 事件及时销毁
- 合理使用异步组件
- 合理使用 keep-alive
- data 层级不要太深（响应式绑定递归遍历比较深）
- webpack 层面的优化
- 前端通用性能优化 （图片懒加载等）
- 使用SSR

## 二、vue3.0 部分

### 1）、vue3 升级内容

- 全部使用 ts 重写 （响应式，vdom,模板编译）
- 性能提升，打包后代码减少
- 调整部分API 

### 2）、proxy 重写响应式

#### （1）、proxy 的基本使用

    const data = {
	    name: 'zhangsan',
	    age: 20,
	}
	
	const proxyData = new Proxy(data, {
	    get(target, key, receiver) {
	        const result = Reflect.get(target, key, receiver)
	        console.log('get',key)
	        return result // 返回结果
	    },
	    set(target, key, val, receiver) {
	        const result = Reflect.set(target, key, val, receiver)
	        console.log('set', key, val)
	        return result // 是否设置成功
	    },
	    deleteProperty(target, key) {
	        const result = Reflect.deleteProperty(target, key)
	        console.log('delete property', key)
	        return result // 是否删除成功
	    }
	})

Reflect 和 Proxy 是搭配使用的。

Reflect 的作用

- Reflect 和 Proxy 的能力一一对应。
- 规范化、标准化、函数式。（如查找一个对象中的 key 一般是 "a" in obj, Reflects是 Reflect.has(obj,"a"), 删除的话 delete obj.a ,  ReflecteleteProperty(obj,"a")）
- 代替 Object 上的工具函数

#### （1）、proxy 实现响应式

    // 创建响应式
	function reactive(target = {}) {
	    if (typeof target !== 'object' || target == null) {
	        // 不是对象或数组，则返回
	        return target
	    }
	
	    // 代理配置
	    const proxyConf = {
	        get(target, key, receiver) {
	            // 只处理本身（非原型的）属性
	            const ownKeys = Reflect.ownKeys(target)
	            if (ownKeys.includes(key)) {
	                console.log('get', key) // 监听
	            }
	    
	            const result = Reflect.get(target, key, receiver)
	        
	            // 深度监听
	            // 性能如何提升的？
	            return reactive(result)
	        },
	        set(target, key, val, receiver) {
	            // 重复的数据，不处理
	            if (val === target[key]) {
	                return true
	            }
	    
	            const ownKeys = Reflect.ownKeys(target)
	            if (ownKeys.includes(key)) {
	                console.log('已有的 key', key)
	            } else {
	                console.log('新增的 key', key)
	            }
	
	            const result = Reflect.set(target, key, val, receiver)
	            console.log('set', key, val)
	            // console.log('result', result) // true
	            return result // 是否设置成功
	        },
	        deleteProperty(target, key) {
	            const result = Reflect.deleteProperty(target, key)
	            console.log('delete property', key)
	            // console.log('result', result) // true
	            return result // 是否删除成功
	        }
	    }
	
	    // 生成代理对象
	    const observed = new Proxy(target, proxyConf)
	    return observed
	}
	
	// 测试数据
	const data = {
	    name: 'zhangsan',
	    age: 20,
	    info: {
	        city: 'beijing',
	        a: {
	            b: {
	                c: {
	                    d: {
	                        e: 100
	                    }
	                }
	            }
	        }
	    }
	}
	
	const proxyData = reactive(data)
	


- 深度监听，不是全部一次性监听，性能更好
- 可监听 新增/删除 属性
- 可监听数组变化


## 三、react部分

### react组件如何通讯

- props 自定义事件
- context
- redux

### context是什么，有何用途

想子组件派发数据，跨组件、跨级传递数据。

### shouldComponentUpdate的用途

性能优化，

### 描述redux的单向数据流

详见下方的单向数据流

### setState的是同步还是异步

在 React 库控制时，异步；否则同步。详见下方 setState 

### 1、jsx 基本使用

- 变量、表达式
- class style
- 子元素和组件

### 2、循环、判断

不解释

### 3、事件

- bind this
- 关于 event 参数
- 传递自定义参数

#### 1）、this的绑定

改变 this 的指向

1. 初始化 bind 的方式 （ 只在初始化 bind ）
2. 在定义方法的时候 bind 。 不建议使用 （多次bind）
3. 通过箭头函数的形式。 
4. 静态方法 this 永远是 当前实例。（推荐使用）


#### 2）、关于 event 参数

- event.preventDefault() 阻止默认行为
- event.stopPropagetion() 阻止冒泡
- event.target 指向当前元素，即当前元素触发
- event.currentTaget 指向当前元素 假象！！！

react 中的 event 是 react 自己封装的， 不是原生的 event 。可以看 __proto__.constructor 是 SyntheticEvent (组合事件)，可以通过 event.nativeEvent 获取原生 event 。原生 event __proto__.constructor 是 MouseEvent 。

1. event 是 SyntheticEvent (合成事件) 模拟出 DOM 事件的所有能力
2. event.nativeEvent 是原生事件
3. 所有事件都被挂载到 document 
4. 和 dom 事件不一样 和 vue 事件也不一样

#### 3）、传递自定义参数

正常传参数，最后一个参数是 event。

### 4、表单

- 受控组件/非受控组件
- 表单的基本使用 input textare select 用 value
- checkbox radio 用 checked

	`受控组件： 在HTML中，标签<input>、<textarea>、<select>的值的改变通常是根据用户输入进行更新。在React中，可变状态通常保存在组件的状态属性中，并且只能使用 setState() 更新，而呈现表单的React组件也控制着在后续用户输入时该表单中发生的情况，以这种由React控制的输入表单元素而改变其值的方式，称为：“受控组件”。`

1. 通过 value 和 onChange 实现。
2. lable 中的for 使用 htmlFor 代替

非受控组件使用场景： 

- 必须手动操作 DOM 元素，setState 实现不了
- 文件上传 <input type=file />
- 某个富文本编辑器，需要传入 DOM 元素

受控组件 VS 非受控组件

- 优先使用受控组件，符合 React 设计原则（数据驱动视图）。
- 必须手动操作 DOM ，在使用非受控组件

### 5、组件使用

#### 1）、props 传递数据

- 在组件上定一个属性
- 通过 this.props.属性 接收

#### 2）、props 传递函数

- 在组件上定一个属性
- 通过 this.props.属性() 调用

#### 3）、props 类型检查

	import PropTypes from 'prop-types';

	MyComponent.propTypes = {
	  // JS原始类型，这些全部默认是可选的
	  optionalArray: PropTypes.array,
	  optionalBool: PropTypes.bool,
	  optionalFunc: PropTypes.func,
	  optionalNumber: PropTypes.number,
	  optionalObject: PropTypes.object,
	  optionalString: PropTypes.string,
	  optionalSymbol: PropTypes.symbol,
	
	  // 可以直接渲染的任何东西，可以是数字、字符串、元素或数组
	  optionalNode: PropTypes.node,
	
	  // React元素
	  optionalElement: PropTypes.element,
	
	  // 指定是某个类的实例
	  optionalMessage: PropTypes.instanceOf(Message),
	
	  // 可以是多个值中的一个
	  optionalEnum: PropTypes.oneOf(['News', 'Photos']),
	
	  // 可以是多种类型中的一个
	  optionalUnion: PropTypes.oneOfType([
	    PropTypes.string,
	    PropTypes.number,
	    PropTypes.instanceOf(Message)
	  ]),
	
	  // 只能是某种类型的数组
	  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),
	
	  // 具有特定类型属性值的对象
	  optionalObjectOf: PropTypes.objectOf(PropTypes.number),
	
	  // 具有相同属性值的对象
	  optionalObjectWithShape: PropTypes.shape({
	    color: PropTypes.string,
	    fontSize: PropTypes.number
	  }),
	
	  // 必选条件，可以配合其他验证器，以确保在没有提供属性的情况下发出警告
	  requiredFunc: PropTypes.func.isRequired,
	
	  // 必选条件，提供的属性可以为任意类型
	  requiredAny: PropTypes.any.isRequired,
	
	  // 自定义‘oneOfType’验证器。如果提供的属性值不匹配的它应该抛出一个异常
	  // 注意：不能使用‘console.warn’ 和 throw
	  customProp: function(props, propName, componentName) {
	    if (!/matchme/.test(props[propName])) {
	      return new Error(
	        'Invalid prop `' + propName + '` supplied to' +
	        ' `' + componentName + '`. Validation failed.'
	      );
	    }
	  },
	
	  // 自定义‘arrayOf’或者‘objectOf’验证器。
	  // 它会调用每个数组或者对象的key，参数前两个是对象它本身和当前key
	  // 注意：不能使用‘console.warn’ 和 throw
	  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
	    if (!/matchme/.test(propValue[key])) {
	      return new Error(
	        'Invalid prop `' + propFullName + '` supplied to' +
	        ' `' + componentName + '`. Validation failed.'
	      );
	    }
	  })
	};

### 6、setState

1. 不可变值/数据
2. 可能是异步更新
3. 可能会被合并

#### 1）、 不可变值

不能提前对 state 值进行修改，不能应该 state 设置之前的值

不能直接操作 state 值， 只能通过 setState 改变。


	// 不可变值（函数式编程，纯函数） - 数组
	const list5Copy = this.state.list5.slice()
	list5Copy.splice(2, 0, 'a') // 中间插入/删除
	this.setState({
	    list1: this.state.list1.concat(100), // 追加
	    list2: [...this.state.list2, 100], // 追加
	    list3: this.state.list3.slice(0, 3), // 截取
	    list4: this.state.list4.filter(item => item > 100), // 筛选
	    list5: list5Copy // 其他操作
	})
	// 注意，不能直接对 this.state.list 进行 push pop splice 等，这样违反不可变值
	
	// 不可变值 - 对象
	this.setState({
	    obj1: Object.assign({}, this.state.obj1, {a: 100}),
	    obj2: {...this.state.obj2, a: 100}
	})
	// 注意，不能直接对 this.state.obj 进行属性设置，这样违反不可变值



#### 2）、 可能是异步更新

在 React 库控制时，异步；否则同步。

同步的情况：

setTimeout，自己定义的 DOM 事件 等 非 React库控制时为同步执行

异步的情况：

 React 库控制时，比如onChange、onClick、onTouchMove等，这些事件处理程序中的setState都是异步处理的。


React是怎样控制异步和同步的呢？

在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates将isBatchingUpdates修改为true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。

#### 3）、 可能会被合并

- 传入对象，会被合并（类似 Object.assign ）。结果值执行一次

        this.setState({
            count: this.state.count + 1
        })
        this.setState({
            count: this.state.count + 1
        })
        this.setState({
            count: this.state.count + 1
        })

- 传入的函数，不会被合并。

	 	// 执行结果是 +3
        this.setState((prevState, props) => {
            return {
                count: prevState.count + 1
            }
        })
        this.setState((prevState, props) => {
            return {
                count: prevState.count + 1
            }
        })
        this.setState((prevState, props) => {
            return {
                count: prevState.count + 1
            }
        })

### 7、组件生命周期

##### 1）、单组件

挂载时：constructor -> render -> componentDidMount

更新时：props、setState等 -> render -> componentDidUpdate

常用生命周期： 

![Vue](http://blog.liuxiuqian.com:8000/getFile/uploaded/2020-05-01/1588332964606.jpg)

不常用生命周期： 

![Vue](http://blog.liuxiuqian.com:8000/getFile/uploaded/2020-05-01/1588332971378.jpg)

##### 2）、父子组件

和 vue 的完全一样。

### 8、React 高级属性 ---- 性能优化

##### 1）、shouldComponentUpdate 

返回 true ,表示可以渲染。返回 false 不可渲染。默认返回 true 。

    shouldComponentUpdate(nextProps, nextState) {
        if (nextState.count !== this.state.count) {
            return true // 可以渲染
        }
        return false // 不重复渲染
    }

既然有个功能 为什么默认返回 true , 为什么可定制化。

- 默认父组件更新，子组件无条件更新


##### 2）、PureComponent （纯组件） 和 React.memo 

- PureComponent， shouldComponentUpdate 中实现了浅比较 （class 组件）
- memo 函数组件中的 PureComponent
- 浅比较已经适应大部分情况（尽量不要做深度比较）


##### 3）、不可变值 immutable.js 

- 彻底拥抱 不可变值
- 基于共享数据（不是深拷贝），速度好
- 有一定学习和迁移成本，按需引用

什么是 Immutable Data

- mmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象
- Immutable 实现的原理是 Persistent Data Structure （持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变
- 同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗， Immutable 使用了 Structural Sharing···· （结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

为什么要在React.js中使用Immutable

- 它是一个完全独立的库，无论基于什么框架都可以用它。意义在于它弥补了 Javascript 没有不可变数据结构的问题
- 由于是不可变的，可以放心的对对象进行任意操作。在 React 开发中，频繁操作state对象或是 store ，配合 immutableJS 快、安全、方便
- 熟悉 React.js 的都应该知道， React.js 是一个 UI = f(states) 的框架，为了解决更新的问题， React.js 使用了 virtual dom ， virtual dom 通过 diff 修改 dom ，来实现高效的 dom 更新。
- 但是有一个问题。当 state 更新时，如果数据没变，你也会去做 virtual dom 的 diff ，这就产生了浪费。这种情况其实很常见
- 当然你可能会说，你可以使用 PureRenderMixin 来解决呀， PureRenderMixin 是个好东西，我们可以用它来解决一部分的上述问题
- 但 PureRenderMixin 只是简单的浅比较，不使用于多层比较。那怎么办？自己去做复杂比较的话，性能又会非常差
- 方案就是使用 immutable.js 可以解决这个问题。因为每一次 state 更新只要有数据改变，那么 PureRenderMixin 可以立刻判断出数据改变，可以大大提升性能


### 9、React 高级属性 ---- 高阶组件 HOC  (抽离公共逻辑)

一个高阶组件只是一个包装了另外一个 React 组件的 React 组件。这种形式通常实现为一个函数，本质上是一个类工厂（class factory）

高阶组件的作用就是实现组件复用，节省内存

- 先定义一个函数式组价，传入一个参数，这个参数就是组件
- 组件内返回一个class类组件，类名可以写也可以不写
- 类组件内部可以写方法，数据，然后将参数当做组件返回出去，并将方法或者数据，传个这个组件

例子1：

	    import React,{ Component } from 'react';
		
		const Hoc = ( Comp ) =>{//参数首字母必须大写，必须要有返回值，在下面使用
		    return class banner extends Component{ //类名可以省略，省略的话标签名就是以temp或者其他的代替，必须要有返回值
		        banner = () => {//这里是实现某个功能的函数代码
		            return 'zhangyue'
		        }
		        render () {
		            return (
		                <Comp banner = { this.banner }></Comp>//将参数当做一个组件返回出去
		            )
		        }
		    }
		}
		class A extends Component{
		    render () {
		        return (
		            <div>
		                <p> A组件 </p>
		                { this.props.banner() }//在下面使用了高阶组件后，这里就可以直接使用里面的方法了
		            </div>
		        )
		    }
		}
		
		class B extends Component{
		    render () {
		        return (
		            <div>
		                <p> B组件 </p>
		                { this.props.banner() }
		            </div>
		        )
		    }
		}
		
		const HocA = Hoc(A)//组件名必须首字母大写，将组件名当参数传进去，这样这个组件就有高阶组件内的方法了
		const HocB = Hoc(B)
		
		
		class C extends Component{
		    render () {
		        return (
		            <div>
		                <p> C组件 </p>
		                <HocA></HocA>//这里使用的高阶组件
		                <HocB></HocB>
		            </div>
		        )
		    }
		}
		export default C

例子2：

		import React from 'react'

		// 高阶组件
		const withMouse = (Component) => {
		    class withMouseComponent extends React.Component {
		        constructor(props) {
		            super(props)
		            this.state = { x: 0, y: 0 }
		        }
		  
		        handleMouseMove = (event) => {
		            this.setState({
		                x: event.clientX,
		                y: event.clientY
		            })
		        }
		  
		        render() {
		            return (
		                <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
		                    {/* 1. 透传所有 props 2. 增加 mouse 属性 */}
		                    <Component {...this.props} mouse={this.state}/>
		                </div>
		            )
		        }
		    }
		    return withMouseComponent
		}
		
		const App = (props) => {
		    const a = props.a
		    const { x, y } = props.mouse // 接收 mouse 属性
		    return (
		        <div style={{ height: '500px' }}>
		            <h1>The mouse position is ({x}, {y})</h1>
		            <p>{a}</p>
		        </div>
		    )
		}
		
		export default withMouse(App) // 返回高阶函数


### 10、React 高级属性 ---- Render Props (抽离公共逻辑)

给组件添加一个值为函数的属性，这个函数可以在组件渲染（render）的时候调用

核心思想： 通过一个函数将 class 组件的 state 作为 props 传递给纯函数组件。

	import React from 'react'
	import PropTypes from 'prop-types'
	
	class Mouse extends React.Component {
	    constructor(props) {
	        super(props)
	        this.state = { x: 0, y: 0 }
	    }
	  
	    handleMouseMove = (event) => {
	      this.setState({
	        x: event.clientX,
	        y: event.clientY
	      })
	    }
	  
	    render() {
	      return (
	        <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
	            {/* 将当前 state 作为 props ，传递给 render （render 是一个函数组件） */}
	            {this.props.render(this.state)}
	        </div>
	      )
	    }
	}
	Mouse.propTypes = {
	    render: PropTypes.func.isRequired // 必须接收一个 render 属性，而且是函数
	}
	
	const App = (props) => (
	    <div style={{ height: '500px' }}>
	        <p>{props.a}</p>
	        <Mouse render={
	            /* render 是一个函数组件 */
	            ({ x, y }) => <h1>The mouse position is ({x}, {y})</h1>
	        }/>
	        
	    </div>
	)
	
	/**
	 * 即，定义了 Mouse 组件，只有获取 x y 的能力。
	 * 至于 Mouse 组件如何渲染，App 说了算，通过 render prop 的方式告诉 Mouse 。
	 */
	
	export default App

### HOC VS Render Porps

- HOC: 模式简单，但会增加组件层级
- Render Porps： 代码简洁，学习成本较高
- 按需使用吧


### 11、React 高级属性 ---- 函数组件

定义一个函数 只接收 props 然后 return 内容。

- 纯函数，输入 props ，输出 JSX。
- 没有实例，没有生命周期，没有 state。
- 不能扩展其他方法。

 

### 12、React 高级属性 ---- ref 

- React.createRef() 创建 ref
- this.myRef.current 获取 DOM 元素


### 13、React 高级属性 ---- Portals （插槽）

Portals 提供了一种能让子节点渲染到父组件之外的方式。

    React.createPortal(child,container);

第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或碎片。第二个参数（container）则是一个 DOM 元素，挂载到的位置。

    render() {
        // // 正常渲染
        // return <div className="modal">
        //     {this.props.children} {/* vue slot */}
        // </div>

        // 使用 Portals 渲染到 body 上。
        // fixed 元素要放在 body 上，有更好的浏览器兼容性。
        return ReactDOM.createPortal(
            <div className="modal">{this.props.children}</div>,
            document.body // DOM 节点
        )
    }

Portals 使用场景：

- overflow: hidden （父组件设置了 BFC , BFC 不限制子组件的展示，让子组件逃离父组件 ）
- 父组件 z-index 值太小 （让子组件逃离父组件设置 合适的 z-index）
- fixed 需要放在 body 第一层级的

一般都是应对 css 样式布局问题。

### 14、React 高级属性 ---- context

跨组件传递数据，解决 props 传递繁琐， redux 小题大做问题。

context api给出三个概念：React.createContext()、Provider、Consumer；

- React.createContext() ： 创建context对象
- Provider： 数据的生产者，通过value属性接收存储的公共状态，来传递给子组件或后代组件。<Provider value={/* some value */}>
- Consumer ： 数据的消费者，通过订阅Provider传入的context的值，来实时更新当前组件的状态


    import React from 'react'

	// 创建 Context 填入默认值（任何一个 js 变量）
	const ThemeContext = React.createContext('light')
	
	// 底层组件 - 函数式组件
	function ThemeLink (props) {
	    // const theme = this.context // 会报错。函数式组件没有实例，即没有 this
	
	    // 函数式组件可以使用 Consumer
	    return <ThemeContext.Consumer>
	        { value => <p>link's theme is {value}</p> }
	    </ThemeContext.Consumer>
	}
	
	// 底层组件 - class 组件
	class ThemedButton extends React.Component {
	    // 指定 contextType 读取当前的 theme context。
	    // static contextType = ThemeContext // 也可以用 ThemedButton.contextType = ThemeContext
	    render() {
	        const theme = this.context // React 会往上找到最近的 theme Provider，然后使用它的值。
	        return <div>
	            <p>button's theme is {theme}</p>
	        </div>
	    }
	}
	ThemedButton.contextType = ThemeContext // 指定 contextType 读取当前的 theme context。
	
	// 中间的组件再也不必指明往下传递 theme 了。
	function Toolbar(props) {
	    return (
	        <div>
	            <ThemedButton />
	            <ThemeLink />
	        </div>
	    )
	}
	
	class App extends React.Component {
	    constructor(props) {
	        super(props)
	        this.state = {
	            theme: 'light'
	        }
	    }
	    render() {
	        return <ThemeContext.Provider value={this.state.theme}>
	            <Toolbar />
	            <hr/>
	            <button onClick={this.changeTheme}>change theme</button>
	        </ThemeContext.Provider>
	    }
	    changeTheme = () => {
	        this.setState({
	            theme: this.state.theme === 'light' ? 'dark' : 'light'
	        })
	    }
	}
	
	export default App


### 15、React 高级属性 ---- 异步组件

- import() vue 中常用
- React.lazy 
- React.Suspense

组件比较大，路由懒加载的时候 使用

    import React from 'react'

	const ContextDemo = React.lazy(() => import('./ContextDemo'))
	
	class App extends React.Component {
	    constructor(props) {
	        super(props)
	    }
	    render() {
	        return <div>
	            <p>引入一个动态组件</p>
	            <hr />
	            <React.Suspense fallback={<div>Loading...</div>}>
	                <ContextDemo/>
	            </React.Suspense>
	        </div>
			// 验证方式：
	        // 1. 强制刷新，可看到 loading （看不到就限制一下 chrome 网速）
	        // 2. 看 network 的 js 加载
	    }
	}
	
	export default App

### 16、Redux 使用

#### 1）、基本概念

应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。 惟一改变 state 的办法是触发 action，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 reducers。

#### （1）、store state

Redux 应用只有一个单一的 store。唯一的一个。

Store 有以下职责：

- 维持应用的 state；
- 提供 getState() 方法获取 state；
- 提供 dispatch(action) 方法更新 state；
- 通过 subscribe(listener) 注册监听器;
- 通过 subscribe(listener) 返回的函数注销监听器。

#### （2）、action

Action 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。


	{
	  type: ADD_TODO,
	  text: 'Build my first Redux app'
	}

Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。

	import { ADD_TODO, REMOVE_TODO } from '../actionTypes'


#### （3）、reducer

Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。

reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。

	(previousState, action) => newState

例子：

	function todoApp(state = initialState, action) {
	  // 这里暂不处理任何 action，
	  // 仅返回传入的 state。
	  return state
	}

永远不要在 reducer 里做这些操作：

- 修改传入参数；
- 执行有副作用的操作，如 API 请求和路由跳转；
- 调用非纯函数，如 Date.now() 或 Math.random()。

#### 2）、单项数据流

严格的单向数据流是 Redux 架构的设计核心。

Redux 应用中数据的生命周期遵循下面 4 个步骤：

1. 调用 store.dispatch(action)。
2. Redux store 调用传入的 reducer 函数。
3. 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。
4. Redux store 保存了根 reducer 返回的完整 state 树。

#### 3）、react-redux

#### （1）、<Provider store>

<Provider store> 使组件层级中的 connect() 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 <Provider> 中才能使用 connect() 方法。

	ReactDOM.render(
	  <Provider store={store}>
	    <MyRootComponent />
	  </Provider>,
	  rootEl
	)

#### （2）、connect

	connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])

- mapStateToProps: 这个函数允许我们将 store 中的数据作为 props 绑定到组件上。
- mapDispatchToProps: 将 action 作为 props 绑定到组件上，也会成为组件自己的 props。
- 不管是 stateProps 还是 dispatchProps，都需要和 ownProps merge 之后才会被赋给组件。connect 的第三个参数就是用来做这件事。通常情况下，你可以不传这个参数，connect 就会使用 Object.assign 替代该方法。
- [options] (Object) 如果指定这个参数，可以定制 connector 的行为。一般不用。



#### （3）、mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps)

mapStateToProps(state, ownProps):

- 这个函数的第一个参数就是 Redux 的 store，我们从中摘取了 count 属性。你不必将 state 中的数据原封不动地传入组件，可以根据 state 中的数据，动态地输出组件需要的（最小）属性。
- 函数的第二个参数 ownProps，是组件自己的 props。有的时候，ownProps 也会对其产生影响。

当 state 变化，或者 ownProps 变化的时候，mapStateToProps 都会被调用，计算出一个新的 stateProps，（在与 ownProps merge 后）更新给组件。

mapDispatchToProps(dispatch, ownProps):

- 第一个参数就是 dispatch 方法
- 同上

#### （3）、

#### 4）、异步 action

![Vue](http://blog.liuxiuqian.com:8000/getFile/uploaded/2020-05-02/1588413261015.jpg)

需要引入中间件 redux-thunk

	let store = createStore(
	  combineReducers({...home,...log}),
	  applyMiddleware(thunk，...),//加入中间件redux-thunk，applyMiddleware就是Redux的一个原生方法，将所有中间件组成一个数组，依次执行。
	);

原来的store.dispatch方法只能接收一个普通的action对象作为参数，当我们加入了ReduxThunk这个中间件之后，store.dispatch还可以接收一个方法作为参数，这个方法会接收到两个参数，第一个是dispatch，等同于store.dispatch，第二个是getState，等同于store.getState，也就是说，现在可以这样来触发INCREASE：

	store.dispatch((dispatch, getState) => dispatch({type: 'INCREASE'}));

#### 5）、中间件

![Vue](http://blog.liuxiuqian.com:8000/getFile/uploaded/2020-05-02/1588414000590.jpg)

中间件 对原 dispatch 进行改造，获取原 dispatch 处理逻辑 然后传给 真正的 dispatch

![Vue](http://blog.liuxiuqian.com:8000/getFile/uploaded/2020-05-02/1588414371363.jpg)


### 17、React-router

- 路由模式 （hash , H5 history）， 同 vue-router
- 路由配置 （懒加载，动态路由），同 vue-router

### 18、函数是编程

- 纯函数
- 不可变值


### 19、Vdom 和 diff 算法

回顾：
 
- h 函数： 传入 tag 属性 子节点 返回 vnode 数据结构
- vnode 数据结构 
- patch 函数
- 只比较同一层级，不跨级比较
- tag 不相同，则直接删掉重建，不在深度比较
- tag 和 key 两者都相同 则认为是相同节点，不在深度比较



### 20、合成事件

- event 是 SyntheticEvent (合成事件) 模拟出 DOM 事件的所有能力
- 所有的事件都挂载到 document 上
- 和 vue 事件不同，和 原生 Dom 不同

![Vue](http://blog.liuxiuqian.com:8000/getFile/uploaded/2020-05-03/1588499144783.jpg)

为什么要使用合成事件？

- 更好的兼容性和跨平台
- 挂载到 document , 减少内存消耗，避免频繁解绑
- 方便事件的统一管理 （如事务机制）



### 21、setState 和 batchUpdate

#### 1）、setState

- 有时异步（普通使用），有时同步（非 react setTimeout Dom 事件）
- 有时合并 （对象形式），有时不合并 （函数形式）

真正判断是否同步或者异步：

- 看是否命中 batchUpdate 机制
- 判断 isBatchUpdates 

#### 2）、batchUpdate 机制

在React的生命周期和合成事件执行前后都有相应的钩子，分别是pre钩子和post钩子，pre钩子会调用batchedUpdate方法将isBatchingUpdates变量置为true，开启批量更新，而post钩子会将isBatchingUpdates置为false


![Vue](http://blog.liuxiuqian.com:8000/getFile/uploaded/2020-05-03/1588500218409.png)

isBatchingUpdates变量置为true，则会走批量更新分支，setState的更新会被存入队列中，待同步代码执行完后，再执行队列中的state更新。

而在原生事件和异步操作中，不会执行pre钩子，或者生命周期的中的异步操作之前执行了pre钩子，但是pos钩子也在异步操作之前执行完了，isBatchingUpdates必定为false，也就不会进行批量更新。

#### 3）、transaction 事务机制

![Vue](http://blog.liuxiuqian.com:8000/getFile/uploaded/2020-05-03/1588500870082.jpg)


我们可以这样理解事务，react中用事务执行方法，就是用wrapper（称之为套套吧）把方法包裹起来，然后每个wapper中都提供一个initialize方法和一个close方法，当需要使用事务调用一个方法，例如上图中的anyMethod时，使用事务提供的perform方法，将需要执行的方法传入，这个时候就会按顺序执行wrapper.initalize，anyMethod,wrapper.close，而且，事务还支持多个事务的嵌套，当执行方法被多个wapper包裹时，事务会先按顺序执行所有的initalize方法，再执行anyMethod，最后按顺序执行所有的close函数，例如上图就表示会按以下顺序执行wrapper1.initalize,wrapper2.initalize,anyMethod,wrapper1.close,wrapper2.close


### 22、组件渲染过程

创建过程：
- props state
- render() 生成 vnode
- patch(elem,vnode) 生成节点

注：patch react 中不一定是 patch 函数生成的，有可能是其他名字，原理和 patch 函数相同。


更新过程：

- setState(newState) ---> dirtyComponents (有可能子组件)
- render() 生成 newVnode 
- patch(elem,vnode)创建节点

patch 拆分两个阶段：

1. renconciliation 阶段----执行 diff 算法，纯 js 计算
2. commit 计算----将 diff 结果渲染到 DOM


如果不拆分可能存在的问题：

- js 是单线程，且和 DOM 渲染共用一个线程
- 当组件足够复杂，组件更新时计算和渲染都压力大
- 同事再有 DOM 操作需求（动画、鼠标拖拽等），将卡顿..

解决方案 fiber

-  renconciliation 阶段进行任务拆分（commit 无法拆分）
-  DOM 需要渲染的时暂停，空闲时恢复
-  通过 window.requestdleCallback（浏览器有兼容的问题） 判断 DOM 是否渲染完成

fiber架构思想：

改变了之前react的组件渲染机制，新的架构使原来同步渲染的组件现在可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程，

前面是react16以前的组建渲染方式。这就存在一个问题，

如果这是一个很大，层级很深的组件，react渲染它需要几十甚至几百毫秒，在这期间，react会一直占用浏览器主线程，任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行。

### 23、jsx 本质
	
	// https://www.babeljs.cn/
	
	// JSX 基本用法
	const imgElem = <div id="div1">
	    <p>some text</p>
	    <img src={imgUrl}/>
	</div>
	
	// JSX style
	const styleData = { fontSize: '30px',  color: 'blue' }
	const styleElem = <p style={styleData}>设置 style</p>
	
	// JSX 加载组件
	const app = <div>
	    <Input submitTitle={onSubmitTitle}/>
	    <List list={list}/>
	</div>
	
	// JSX 事件
	const eventList = <p onClick={this.clickHandler}>
	    some text
	</p>
	
	// JSX list
	const listElem = <ul>{this.state.list.map((item, index) => {
	    return <li key={item.id}>index {index}; title {item.title}</li>
	})}</ul>
	
	
	// 总结
	React.createElement('div', null, [child1, child2, child3])
	React.createElement('div', {...}, child1, child2, child3)
	React.createElement(List, null, child1, child2, '文本节点')
	// h 函数
	// 返回 vnode
	// patch

第一个参数是 tag 标签 或者 组件 （如果是组件 继续拆分 为 tag 标签）
第二个参数是 属性 有可能是 null 
后边的参数是子元素，有数组和正常参数，也有文本节点

- React.createElement 即 h 函数，返回 vnode 节点
- 第一个参数是 tag 标签 或者 组件
- 组件名首字母大写，html tag 是小写


### 24、React 性能优化

- 渲染列表时加 key
- 自定义事件、Dom 事件及时销毁
- 合理使用异步组件
- 减少函数 bind this 的次数
- 合理使用 shouldComponentUpdate PureComponent （纯组件） 和 React.memo 
- 合理使用 Immutable.js ( 不可变值 )
- webpack
- 前端通用的性能优化
- 使用 ssr

### 25、React 和 Vue 的区别

共同点：

- 都支持组件化
- 都是数据驱动视图
- 都使用 Vdom 操作 DOM 

区别：

- React 使用 JSX 拥抱 js, Vue 使用模板拥抱 html
- React 函数式编程， Vue 是声明式编程
- React 更多的是自力更生 （比较灵活），Vue 把想要的都给你 （比较固定，使用简单）



## 四、webpack部分


### 前端代码为何要进行构建和打包

### loader和plugin的区别

### 如何实现懒加载

### 常见性能优化

### babel-runtime和 bable-polyfill的区别

### 1、拆分配置和 merge

使用 webpack-merge 进行配置合并

我们在根目录下创建config文件夹，并创建四个配置文件：

- webpack.comm.js 公共环境的配置文件
- webpack.development.js 开发环境下的配置文件
- webpack.production.js 生产环境下的配置文件
- webpack.parts.js 各个配置零件的配置文件 

使用

	
	const merge = require('webpack-merge'); 
	const common = require('./webpack.common.js'); // 公共的配置
	module.exports = merge(common, {...});  // {...} // 自己单独写的配置内容
	

### 2、rules 


	{
        test: /\.js$/,
        loader: ['babel-loader'],
        include: srcPath,
        exclude: /node_modules/
    },

1. test

### 3、多入口打包

### 4、css 分离打包

1. mini-css-extract-plugin 安转这个插件



在 rules 中加入 

 	// 抽离 css
    {
        test: /\.css$/,
        loader: [
            MiniCssExtractPlugin.loader,  // 注意，这里不再用 style-loader
            'css-loader',
            'postcss-loader' // 兼容浏览器增加前缀
        ]
    },
    // 抽离 less --> css
    {
        test: /\.less$/,
        loader: [
            MiniCssExtractPlugin.loader,  // 注意，这里不再用 style-loader
            'css-loader',
            'less-loader',  
            'postcss-loader' // 兼容浏览器增加前缀
        ]
    }


在 plugins 中加入 输出位置


	// 抽离 css 文件
    new MiniCssExtractPlugin({
        filename: 'css/main.[contentHash:8].css'
    })

压缩 CSS 

安转引入 :

	const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin')
	// 在 optimization 引入压缩插件
	optimization: {
        // 压缩 css
        minimizer: [ new OptimizeCSSAssetsPlugin({})],
    }

### 5、抽离公共代码单独打包 和 抽离第三方代码单独打包

optimization 中配置

	// 分割代码块
    splitChunks: {
        chunks: 'all',
        /**
         * initial 入口 chunk，对于异步导入的文件不处理
            async 异步 chunk，只对异步导入的文件处理
            all 全部 chunk
         */

        // 缓存分组
        cacheGroups: {
            // 第三方模块
            vendor: {
                name: 'vendor', // chunk 名称
                priority: 1, // 权限更高，优先抽离，重要！！！
                test: /node_modules/,
                minSize: 0,  // 大小限制 （超过这个大小开始分离单独包）
                minChunks: 1  // 最少复用过几次
            },

            // 公共的模块
            common: {
                name: 'common', // chunk 名称
                priority: 0, // 优先级
                minSize: 0,  // 公共模块的大小限制
                minChunks: 2  // 公共模块最少复用过几次
            }
        }
    }

注意、： 在多入口 html 中引入 chunks 需要配置完整

        new HtmlWebpackPlugin({
            template: path.join(srcPath, 'index.html'),
            filename: 'index.html',
            // chunks 表示该页面要引用哪些 chunk （即上面的 index 和 other），默认全部引用
            chunks: ['index', 'vendor', 'common']  // 要考虑代码分割
        }),

### 6、异步加载

当js页面特别多的时候，如果都打包成一个文件，那么很影响访问页面访问的速度。理想的情况下，是到相应页面的时候才下载相应页面的js。

解决方案：使用import('path/to/module') -> Promise。调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。

	import("./utils/emonitor").then(({emonitorReport}) => {
	    emonitorReport();
	  });

### 7、 module chunk bundle 分别是什么意思，什么区别

- module ---- 各个源码文件， webpack 中一切皆模块
- chunk  ---- 多模块合成，是webpack处理过程中被分组了的modules，如代码分割时一个异步加载的chunk可能包含多个module
- bundle ---- 最终的输出的文件

### 8、完整的配置

	// 处理html
	const HtmlWebPackPlugin = require('html-webpack-plugin')
	// 清空dist
	const CleanWebpackPlugin = require('clean-webpack-plugin')
	// 分离CSS
	const MiniCssExtractPlugin = require('mini-css-extract-plugin')
	// 压缩js
	const TerserJSPlugin = require('terser-webpack-plugin');
	// 压缩css
	const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');
	// 处理文件的绝对路径
	const path = require('path');
	// body-parser中间件，处理post请求传参
	const bodyParser = require('body-parser');
	
	module.exports = {
	    // 入口文件
	    entry: './src/index.js',
	    // entry: {
	    //     index: './src/index.js',
	    //     order: './src/order.js'
	    // },
	
	    // 出口配置
	    output: {
	        filename: 'assets/[name].[hash:6].js',  // 生成文件的名字
	        publicPath: '/dist',
	        path: path.join(__dirname, 'dist')  // 生成文件的路径
	    },
	
	    // 加载模块，配置各种loader
	    module: {
	        rules: [
	            {
	                test: /\.(sass|scss|css)$/,
	                use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader']
	            },
	            {
	                test: /\.(jpe?g|png|gif|svg)$/i,
	                use: {
	                    loader: 'url-loader',
	                    options: {
	                      // 1024 = 1kb
	                      limit: 10240,
	                      name: 'assets/[name].[hash:6].[ext]',
	                    }
	                }
	            },
	            {
	                test: /\.(eot|ttf|svg|woff2?)$/,
	                use: ['url-loader']
	            }
	        ]
	    },
	    // 插件
	    plugins: [
	        // 打包前清空
	        new CleanWebpackPlugin(),
	        // 自动注入
	        new HtmlWebPackPlugin({
	            template: './src/index.html',
	            filename: 'index.html',
	            inject: true
	        }),
	        // 抽离css
	        new MiniCssExtractPlugin({
	            filename: 'assets/[name].css',
	            chunkFilename: 'assets/[id].css'
	        })
	    ],
	    // 服务配置
	    devServer: {
	        // open: true, // 自动打开浏览器
	        port: 10001,    // 指定端口号
	        host: '0.0.0.0',
	        hot: true,   // 热更新
	        before(app){    // 请求拦截
	            app.post('/loader/list', bodyParser.json(), (req, res, next)=>{
	                console.log('req...', req);
	                console.log('查询参数...', req.query);
	                console.log('body体...', req.body)
	                res.json({
	                    code: 1,
	                    msg: '请求成功',
	                    data: ['node-sass', 'sass-loader', 'css-loader', 'file-loader', 'url-loader', 'style-loader']
	                })
	            })
	        }
	    },
	    resolve: {
	        // 配置别名
	        alias: {
	            '@': path.join(__dirname, 'src')
	        }
	    },
	    // 优化的配置
	    optimization: {
	        minimizer: [
	            // 压缩js
	            new TerserJSPlugin({}),
	            // 压缩css
	            new OptimizeCSSAssetsPlugin({})
	        ],
	        // 包的分离，分离出非业务逻辑相关的包
	        splitChunks: {
	            cacheGroups: {
	                vendor: {   // 抽离第三方插件
	                    test: /node_modules/,   // 指定是node_modules下的第三方包
	                    chunks: 'initial',
	                    name: 'vendor',  // 打包后的文件名，任意命名    
	                    // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包
	                    priority: 10    
	                },
	                utils: { // 抽离自己写的公共代码，utils这个名字可以随意起
	                    chunks: 'initial',
	                    name: 'utils',  // 任意命名
	                    minChunks: 2,   // 引用次数最少两次
	                    minSize: 0    // 只要超出0字节就生成一个新包
	                }
	            }
	        }
	    }
	}

### 8、webpack 性能优化 ---- 优化打包构建速度

#### 1）、优化 babel-loader （编译 es6 代码到 es5 还是比较耗时的）

cacheDirectory：默认值为 false。当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程(recompilation process)。如果设置了一个空值 (loader: 'babel-loader?cacheDirectory') 或者 true (loader: babel-loader?cacheDirectory=true)，loader 将使用默认的缓存目录 node_modules/.cache/babel-loader，如果在任何根目录下都没有找到 node_modules 目录，将会降级回退到操作系统默认的临时文件目录。

	 {
        test: /\.js$/,
        loader: ['babel-loader?cacheDirectory'], // 开启缓存
        include: path.resolve(__dirname, 'src'), // 明确范围
        // exclude: /node_modules/
    },

loader 是 use 的简写形式

#### 2）、IgnorePlugin 避免那些不需要打包的 

	// 忽略 moment 下的 /locale 目录
    new webpack.IgnorePlugin(/\.\/locale/, /moment/),


#### 3）、noPares 不需要管理的

webpack精准过滤不需要解析的文件

webpack配置中 module配置下有一条配置项叫noParse

	module:{
        noParse: /jquery|lodash/,  //接收参数  正则表达式 或函数
        noParse:function(contentPath){
            return /jquery|lodash/.test(contentPath);
        }
    }


#### 4）、happyPack 多进程打包

- js 单线程，可以开启多进程打包
- 提高构建速度

配置happyPack：

rules 中
	
    {
        test: /\.js$/,
        // 把对 .js 文件的处理转交给 id 为 babel （下边指定的 id） 的 HappyPack 实例
        use: ['happypack/loader?id=babel'],
        include: srcPath,
        // exclude: /node_modules/
    },

plugins 中

	// happyPack 开启多进程打包
    new HappyPack({
        // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件
        id: 'babel',
        // 如何处理 .js 文件，用法和 Loader 配置中一样
        loaders: ['babel-loader?cacheDirectory']
    }),



#### 5）、ParallelUglifyPlugin 多进程打包代码压缩

配置使用：

	// 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码
        new ParallelUglifyPlugin({
            // 传递给 UglifyJS 的参数
            // （还是使用 UglifyJS 压缩，只不过帮助开启了多进程）
            uglifyJS: {
                output: {
                    beautify: false, // 最紧凑的输出
                    comments: false, // 删除所有的注释
                },
                compress: {
                    // 删除所有的 `console` 语句，可以兼容ie浏览器
                    drop_console: true,
                    // 内嵌定义了但是只用到一次的变量
                    collapse_vars: true,
                    // 提取出出现多次但是没有定义成变量去引用的静态值
                    reduce_vars: true,
                }
            }
        })

#### 6）、自动刷新和热更新

自动刷新：


 	watch: true, // 开启监听，默认为 false
    watchOptions: {
        ignored: /node_modules/, // 忽略哪些
        // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高
        // 默认为 300ms
        aggregateTimeout: 300,
        // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的
        // 默认每隔1000毫秒询问一次
        poll: 1000
    }

热更新：

	  devServer: {
	    contentBase: path.join(__dirname, 'dist'),
	    compress: true,
	    port: 9000,
	    hot: true
	  },

- 自动刷新： 整个网页全部刷新，速度较慢，状态会丢失
- 热更新： 新代码生效，网页不刷新，状态不丢失


#### 7）、DllPlugin 预打包第三方库

- 前端框架如 vue React，体积较大，构建慢
- 较稳定，不常升级版本
- 同一个版本只构建一次即可，不用每次都重新构建
- webpack 已内置 DllPlugin
- DllPlugin --- 打包出 dll 文件
- DllReferencePlugin --- 使用 dll 文件

配置 dll 

	const path = require('path')
	const DllPlugin = require('webpack/lib/DllPlugin')
	const { srcPath, distPath } = require('./paths')
	
	module.exports = {
	  mode: 'development',
	  // JS 执行入口文件
	  entry: {
	    // 把 React 相关模块的放到一个单独的动态链接库
	    react: ['react', 'react-dom']
	  },
	  output: {
	    // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，
	    // 也就是 entry 中配置的 react 和 polyfill
	    filename: '[name].dll.js',
	    // 输出的文件都放到 dist 目录下
	    path: distPath,
	    // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react
	    // 之所以在前面加上 _dll_ 是为了防止全局变量冲突
	    library: '_dll_[name]',
	  },
	  plugins: [
	    // 接入 DllPlugin
	    new DllPlugin({
	      // 动态链接库的全局变量名称，需要和 output.library 中保持一致
	      // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值
	      // 例如 react.manifest.json 中就有 "name": "_dll_react"
	      name: '_dll_[name]',
	      // 描述动态链接库的 manifest.json 文件输出时的文件名称
	      path: path.join(distPath, '[name].manifest.json'),
	    }),
	  ],
	}

配置引用

	// 第三，告诉 Webpack 使用了哪些动态链接库
    new DllReferencePlugin({
        // 描述 react 动态链接库的文件内容
        manifest: require(path.join(distPath, 'react.manifest.json')),
    }),

HTML 中引入

	 <script src="./react.dll.js"></script>

配置启动命令

	    "dll": "webpack --config build/webpack.dll.js"

更多配置参考：

[https://blog.csdn.net/janyxh/article/details/100131082](https://blog.csdn.net/janyxh/article/details/100131082 "https://blog.csdn.net/janyxh/article/details/100131082")


##### 8）、webpack 优化构建速度---可用于生成环境的

- 优化 babel-loader
- IgnorePlugin
- noPares
- happyPack
- ParallelUglifyPlugin

##### 9）、webpack 优化构建速度---不可用于生成环境的

- 自动刷新
- 热更新
- DllPlugin

### 9、webpack 性能优化 ---- 优化产出代码

- 体积更小
- 合理分包，不重复加载
- 速度更快，内存使用更少

解决：

- 小图片转 base64 
- bundle 加 hash 资源缓存 
- 懒加载 
- 提取公共代码
- IgnorePlugin 
- 使用 CDN 加速
- 使用 production
- Scope Hosting


### 10、文件指纹是什么？怎么用？

文件指纹是打包后输出的文件名的后缀。

- Hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改
- Chunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash
- Contenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变

#### 1）、JS的文件指纹设置

设置 output 的 filename，用 chunkhash。

	module.exports = {
	    entry: {
	        app: './scr/app.js',
	        search: './src/search.js'
	    },
	    output: {
	        filename: '[name][chunkhash:8].js',
	        path:__dirname + '/dist'
	    }
	}

#### 2）、CSS的文件指纹设置

设置 MiniCssExtractPlugin 的 filename，使用 contenthash。

	module.exports = {
	    entry: {
	        app: './scr/app.js',
	        search: './src/search.js'
	    },
	    output: {
	        filename: '[name][chunkhash:8].js',
	        path:__dirname + '/dist'
	    },
	    plugins:[
	        new MiniCssExtractPlugin({
	            filename: `[name][contenthash:8].css`
	        })
	    ]
	}

#### 3）、图片的文件指纹设置

设置file-loader的name，使用hash。

占位符名称及含义

- ext     资源后缀名
- name    文件名称
- path    文件的相对路径
- folder  文件所在的文件夹
- contenthash   文件的内容hash，默认是md5生成
- hash         文件内容的hash，默认是md5生成
- emoji        一个随机的指代文件内容的emoj

代码：

	const path = require('path');
	module.exports = {
	    entry: './src/index.js',
	    output: {
	        filename:'bundle.js',
	        path:path.resolve(__dirname, 'dist')
	    },
	    module:{
	        rules:[{
	            test:/\.(png|svg|jpg|gif)$/,
	            use:[{
	                loader:'file-loader',
	                options:{
	                    name:'img/[name][hash:8].[ext]'
	                }
	            }]
	        }]
	    }
	}


### 11、使用 production

 生产环境： mode: "production"

- 自动开启压缩代码 （减少代码的体积，加速下载资源）
- Vue React 等会自动删掉调试代码 （如开发环境的 warning，框架体积变小）
- 自动启用 Tree-Shaking



### 12、Tree-Shaking

Tree-shaking 字面意思就是 摇晃树， 其实就是去除那些引用的但却没有使用的代码


 能够在模块的层面上做到打包后的代码只包含被引用并被执行的模块，而不被引用或不被执行的模块被删除掉，以起到减包的效果。

	relies on the static structure of ES2015 module syntax, i.e. import and export.

在webpack官网当中有这样一句话，翻译成人话就是 Tree-shaking 依赖 es6 的模块引入或输出语法。如果你的模块引入方式是 require 等乱七八糟的东西。Tree-shaking 将不会起到任何作用。因为es6的模块采用的是静态分析，也就是从字面量对代码进行分析。之前的require是动态分析，必须代码执行到才知道引用的什么模块。

详细参考这个： [https://www.jianshu.com/p/7994b1fc6dfe](https://www.jianshu.com/p/7994b1fc6dfe "https://www.jianshu.com/p/7994b1fc6dfe")

### 13、 ES6 Module 和 Commonjs 区别

- ES6 Module 是静态引入，编译时引入
- Commonjs 动态引入，在执行时引入
- webpack 执行是在 编译的时候 只有 ES6 Module 才能静态分析，实现 Tree-Shaking

### 14、 Scope Hosting 作用域提升

打包前 webpack 自动简化函数结构。这是 webpack 的默认行为，当打包前会简化代码，再塞入打包，是自带优化功能之一

	let a = 1;
	let b = 2;
	let c = 3;
	let d = a + b + c;
	console.log(d)

webpack在生产环境下打包的时候，会直接将d打包成a+b+c的结果，即d直接打包成6.这样就无需声明多个变量再去相加。
webpack在生产环境下会自动省略不必要的代码。
[https://www.webpackjs.com/plugins/module-concatenation-plugin/](https://www.webpackjs.com/plugins/module-concatenation-plugin/ "https://www.webpackjs.com/plugins/module-concatenation-plugin/")

### 15、babel-polyfill

	{
	  "presets": [], //设置转码规则
	  "plugins": []  //设置插件
	}

Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。


core-js 和 regeherator, core-js 支持几乎所有的新语法除 generator 函数。为了兼容所有需要引用 regeherator

	import "core-js/stable";
	import "regenerator-runtime/runtime";

babel-polyfill 就是对  regenerator runtime 和 core-js 的封装。（babel 7.4 之前）

babel 7.4 之后直接 推荐使用 core-js 和 regeherator


按需引入


### 16、babel-runtime

babel-polyfill 会存在问题

- 污染全局环境


babel-polyfill解决了Babel不转换新API的问题，但是直接在代码中插入帮助函数，会导致污染了全局环境，并且不同的代码文件中包含重复的代码，导致编译后的代码体积变大。

Babel为了解决上述问题，提供了单独的包babel-runtime用以提供编译模块的工具函数，启用插件babel-plugin-transform-runtime后，Babel就会使用babel-runtime下的工具函数。

